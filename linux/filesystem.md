# Bourne-Again SHell
- [文件系统概念](#文件系统概念)
- [Data Block](#data-block)
- [Super Block](#super-block)
- [Inode](#inode)
- [最大文件大小](#最大文件大小)
- [特殊文件](#特殊文件)
- [目录权限](#目录权限)
- [特殊权限](#特殊权限)
- [重定向](#重定向)
- [管道](#管道)



***********************************************************



# 文件系统概念
* 文件就是一个字节序列
* 各种设备, 目录, 输入输出设备, 可执行文件等都是文件

# Data Block
* Data Block是放置文件内容数据的地方
* 在格式化时block的大小就固定了(在Ext2文件系统中所支持的block大小有1K, 2K及4K三种), 且每个block都有编号, 以方便inode的记录
* 每个block 内最多只能够放置一个文件的资料, 但一个文件可以放在多个block中
* 若文件小于block , 则该block 的剩余容量就不能够再被使用了

# Super Block
* 记录整个文件系统相关信息的地方, 一般大小为1024bytes, 记录的信息主要有
	* block 与inode 的总量
	* 未使用与已使用的inode / block 数量

# Inode
* 记录文件的相关属性, 以及文件内容放置在哪一个块内. inode除了记录文件的属性外, 同时还必须要具有指针的功能
* Inode记录的一些信息
    * 该文件的拥有者与用户组
    * 该文件的访问模式
    * 该文件的类型
    * 该文件的建立, 改变, 最近一次读取时间, 最近一次的修改时间. 
    * 该文件的大小
    * 该文件的属性标志
    * 该文件的真正内容指针
* 一个Inode有12个直接指向, 一个间接, 一个双间接及一个三间接指向

# 最大文件大小
* 对于ext3
    * ext3文件系统采用32bit的块地址索引空间
    * 在inode条目中, 引用一个块空间符号需要4byte的大小
    * 对于一个inode来说, 设计了12个直接指针索引, 一个间接指针索引, 一个双间接指针索引, 以及一个三间接指针索引
    * 在linux文件系统, 一个block的大小可以为1k,2k,4k, 当block的大小为4k时为最大. 在linux系统中, 每一个文件都要使用一个inode号, 因此要想计算出单个文件所支持的最大空间, 只要知道inode中能够引用多少个block, 而block取最大值4k的时候计算出来的值就是所能支持的单个文件的最大空间

<br>

* 一个inode支持12个直接指针, 因此就表示了12个block
    * 一个inode支持一个间接指针, 也就是一个指针指向了一个block块, 将该block块作为指向最终block的直接指针, 这里是一个block为4K, 指向一个block要占用4byte的空间, 因此一个block的间接指针可以指向4K/4byte的block,即2^10
    * 双间接指针最终则指向：2^102^10=2^20 个block
    * 三间接指针最终执行：2^102^10\*2^10=2^30 个block
* 因此最终的block的个数为：12+2^10+2^20+2^30
* 则最终的大小为：(12+2^10+2^20+2^30)x4KByte
* 则换算成TB的大小为：(12+2^10+2^20+2^30)x4KByte/1024/1024/1024=2TB
![](src/inode.jpg)

# 特殊文件
* 特殊文件(special file, 或设备文件)代表连接在系统上的物理设备, 分为字符设备和块设备两大类
    * 字符特殊文件对应于字符设备(character-oriented device), 如键盘
    * 块特殊文件对应于块设备(block-oriented device), 如磁盘
* 特殊文件一般放在/dev目录下, 该目录为连接到计算机的每一种设备准备了至少一个文件, 应用程序和命令可以像读写普通文件那样, 读写外围设备文件 

# 目录权限
* 目录的主要内容是记录文件名列表和子目录列表, 而不是实际存放数据的地方
* **增加文件/删除文件/移动文件** 这个改动更改了目录的内容, 因此需要文件所在目录的w和x
* **修改文件名** 不需要文件本身得到写入权, 然而因为这个改动更改了目录的内容, 因此需要文件所在目录的w和x

<br>

* r 可以读该目录, 这包括目录下的文件和子目录的名称, 以及他们的所有属性
* w 用户可以添加或删除该目录的条目, 意味着可以删除其中文件或所有文件
* x 可以引用一个目录, 比如使用cd命令移动至目录

存取设定 | 列出目录内文件   | 列出目录内详情 | 进入目录 | 创建文件 | 打印目录内文件
:--     | :--             | :--          | :--      | :--     | :-- 
r--     | √               | ×            | ×        | ×       | ×
--x     | ×               | ×            | √        | ×       | √
r-x     | √               | √            | √        | ×       | √
-w-     | ×               | ×            | ×        | ×       | ×

命令 | 文件本身的 | 文件所在目录的
:-- | :-- | :--
`cd /home/chavez` | / | x
`ls /home/chavez/*.c` | 无 | r
`ls -s /home/chavez/*.c` | 无 | rx
`cat runme` | r | x
`cat>>runme` | w | x
`runexe` | x(如果是二进制文档) | x
`runscript` | rx(如果是脚本) | x
`rm filename` | 无 | xw

# 特殊权限
* **`SUID`** 该属性只对有执行权限的文件有效, 对目录无效. 执行具有SUID权限的程序时, 引发的进程的所有者是程序文件的所有者, 而不是启动程序的用户(除非二者是同一个人). 比如, 如果一个程序的所有者是root且具有SUID属性, 一个普通用户执行此程序时, 如同root执行此程序一样. (请注意该属性对Shell脚本程序无效)该属性为一些特殊程序(如lpr)的启动带来了方便. 但有时也带来了安全隐患: 比如一个具有SUID属性的程序如果在执行时运行了一个shell, 那么用户可以籍此得到系统的最高权限. SUID可用s表示, 如: 
```sh
$ ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 47032 Feb 16  2014 /usr/bin/passwd
```
* **`SGID`** 对于可执行文件, SGID与SUID类似, 引发的进程的所有组是程序文件所属的组. 对于目录, SGID属性会使目录中新建文件的所属组与该目录相同. SGID也可以用s表示, 如: 
```sh
$ ls -l /var
drwxrwsr-x  2 root staff    4096 Apr 10  2014 local
```
* **`Sticky`** 仅对目录有效. 带sticky属性的目录下的文件或目录可以被其拥有者删除或改名. 常利用sticky属性创建这样的目录: 组用户可以在此目录中创建新文件、修改文件内容, 但只有文件所有者才能对自己的文件进行删除或改名. 如系统中的/tmp文件夹. 在属性字符串中, 通常用t表示
```sh
$ ls -l /
drwxrwxrwt   8 root root  4096 Apr  4 23:57 tmp
```

# 重定向

文件描述符(File Description) | 说明
---------------------------- | ----
0                            | 标准输入
1                            | 标准输出
2                            | 错误输出

```sh
# 错误信息应重定向到错误输出, 而不是直接打印
if [[ "$#" > 1 ]]; then
    echo 'Error' >&2
else
    echo 'OK'
fi
```

# 管道
* 管道会创建一个子进程
* 使用`PIPESTATUS`检查管道所有部分的返回码, 但是一旦执行任何其他命令就会覆盖`PIPESTATUS`

```sh
tar -cf - ./* | ( cd "${DIR}" && tar -xf - )
return_codes=( "${PIPESTATUS[@]}" )
if (( return_codes[0] != 0 )); then
  do_something
fi
if (( return_codes[1] != 0 )); then
  do_something_else
fi
```